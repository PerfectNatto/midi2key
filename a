def fold_overlap_add_no_add(
    frames: torch.Tensor,          # (B, win_length, n_frames)  ※C=1 を仮定
    win_length: int,
    hop_length: int,
    output_samples: int,
) -> torch.Tensor:
    """
    torch.nn.functional.fold と同じ 1-D オーバーラップ加算を
    `aten.scatter_add` だけで実装する。
    返り値は (B, 1, 1, output_samples)。
    """

    # (B, win_length, n_frames) → (B, n_frames, win_length)
    frames = frames.transpose(1, 2).contiguous()                 # (B, T, K)
    B, T, K = frames.shape
    assert K == win_length, "win_length とテンソル形状が不一致です"

    # 出力位置インデックス idx[t, k] = t*hop + k
    base = torch.arange(T, device=frames.device) * hop_length    # (T,)
    idx  = (base.unsqueeze(1) + torch.arange(K, device=frames.device))  # (T, K)
    idx  = idx.flatten().unsqueeze(0).expand(B, -1)              # (B, T*K)

    # scatter_add で重複位置をそのまま加算
    y = torch.zeros(B, output_samples, dtype=frames.dtype, device=frames.device)
    y = y.scatter_add(1, idx, frames.reshape(B, -1))             # aten.scatter_add

    return y.view(B, 1, 1, -1)
