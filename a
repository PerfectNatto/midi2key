def fold_overlap_add_idx_norange(
    frames: torch.Tensor,        # (B, win_length, n_frames)
    win_length: int,
    hop_length: int,
    output_samples: int,
) -> torch.Tensor:
    """
    • arange を一切使わない 1-D Overlap-Add
    • 依存演算子: aten.ones / aten.cumsum / aten.add / aten.mul / aten.index_add
      （すべて Vulkan デリゲート対応）
    """
    # (B, K, T) → (B, T, K)
    frames = frames.transpose(1, 2).contiguous()
    B, T, K = frames.shape

    # ---- 0..T-1 を生成（arange なし） -------------------------------
    base = torch.ones(T, dtype=torch.int64, device=frames.device)
    base = base.cumsum(0) - 1                          # (T,) 0,1,2,…

    # ---- 0..K-1 を生成（arange なし） -------------------------------
    kernel_idx = torch.ones(K, dtype=torch.int64, device=frames.device)
    kernel_idx = kernel_idx.cumsum(0) - 1              # (K,)

    # ---- 出力インデックス idx[t, k] = t*hop + k ---------------------
    idx = (base[:, None] * hop_length + kernel_idx)    # (T, K)
    idx = idx.flatten()                                # (T*K,)

    # ---- Overlap-Add -------------------------------------------------
    y = torch.zeros(B, output_samples, device=frames.device,
                    dtype=frames.dtype)
    y = torch.index_add(y, 1, idx, frames.reshape(B, -1))  # aten.index_add

    return y.view(B, 1, 1, -1)
