// backends/vulkan/runtime/graph/ops/impl/Unsqueeze.cpp  ★Patched
// -----------------------------------------------------------------------------
// 修正内容: new_shape の確保長を old_rank + dims.size() に変更し、
//          ループ添字 i をそのまま書込み先に使用。
//          これにより AddressSanitizer が報告した
//          heap-buffer-overflow (old implementation) が解消されます。
// -----------------------------------------------------------------------------

#include <algorithm>
#include <vector>

#include "ComputeGraph.h"   // 仮想ヘッダ: 実際は vkcompute ヘッダ群に合わせてください

namespace vkcompute {

// 旧実装そのまま（抜粋） -------------------------------------------------------
// ※ add_unsqueeze_node はここではダミー実装で示します。
//   本来は ComputeGraph にノードを追加し、shape を更新する関数。
void add_unsqueeze_node(
    ComputeGraph& graph,
    int           src_id,
    int           dst_id,
    int           axis) {
  // ... 既存処理 ...
  (void)graph; (void)src_id; (void)dst_id; (void)axis; // placeholder
}

// ------------------------------ PATCHED ---------------------------------------
void unsqueeze(ComputeGraph& graph, const std::vector<int>& dims) {
  const std::vector<long>& old_shape = graph.current_shape();
  const int old_rank = static_cast<int>(old_shape.size());

  // ★ 修正点 1: new_shape の確保長を正しく計算
  std::vector<long> new_shape(old_rank + static_cast<int>(dims.size()));

  // ★ 修正点 2: dst_idx を廃止し、ループ添字 i をそのまま使用
  int src_idx = 0;
  for (int i = 0; i < old_rank + static_cast<int>(dims.size()); ++i) {
    if (std::find(dims.begin(), dims.end(), i) != dims.end()) {
      new_shape[i] = 1;  // 挿入された axis
    } else {
      new_shape[i] = old_shape[src_idx++]; // 既存次元をコピー
    }
  }

  // 新しい shape をグラフへ登録（具体的 API は実装に合わせて）
  graph.set_shape(new_shape);
}

} // namespace vkcompute
